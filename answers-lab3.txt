Part A

1. It is mainly for protection between user space and the kernel space. The handlers push the arguments
to the specific interrupt's handler and also which function the interrupt. Since we're hardcoding these
info the user doesn't have control over control. If all exceptions were delievered
to the same handler then we won't be able to know which interrupt/exceptions trigged the handler.
We don't have a way to pass the handler the info from the trapframe. We would have to map the IDT descriptor
to the handler and then to the interrupt.

2.
No we didn't have to do anything. user_softint can't invoke the interrupt as its CP bits are not
0. When we map the trap init only CP0 can invoke interrupt 14. The mismatch in the CP bits causes
the processor to throw a 13 interrupt. Right now if the $14 instruction to inoke the kernel's page fault handler
then will just kill the user process.


Part B.

1. The IDT has different levels (DPL) and I had initially set the level to 0 which is kernel's. Thus it was generating
a general protection. I had to change this to 3 because this is expected for user level invocations.

2. These mechanisms are here to protect the kernel from user level influence. The user can ask the kernel to perform
certain task but cannot change virtual memory and the like as softint was doing.


Challenge Problem

I decided to extend monitor to allow for single steping.
This means I had to set the Trace Flag on in the Eflags. Thus I made two new
commands in monitor.c. singlestep will set the TF on thus the kernel will break
after excecuting one instruction. The continue function set the TF to off thus resuming
the execution as before. Inorder for this to work I also modified trap_dipatch to handle the
DEBUG interrupt as well.